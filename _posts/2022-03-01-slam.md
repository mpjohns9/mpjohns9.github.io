---
layout: post
title:  "Feature-based Extended Kalman Filter SLAM (EKF-SLAM) from Scratch"
subtitle: "Sensing, Navigation, and Machine Learning for Robotics"
subsubtitle: "MS in Robotics &#8212 Northwestern University"
categories: [ Machine Learning, SLAM, ROS, C++, Simulation]
image: assets/images/slam.png
gif: assets/images/slam.gif
repo: "https://github.com/mpjohns9/EKF-SLAM"
when: January - March 2022
featured: false
hidden: false
---
Throughout this course, I developed a ROS package and helper libraries in C++ to implement feature-based extended Kalman filter simultaneous localization and mapping (EKF-SLAM). In the video above, three robots and their simulated paths are displayed:
<ul>
    <li><b>Simulated (Red)</b></li>
    This robot represents the ground truth state of the simulation.
    <li><b>Odometry (Blue)</b></li>
    The position of this robot is calculated using wheel velocities and a corresponding body twist. Significant error can be noted and attributed to simulated error such as wheel slippage.
    <li><b>SLAM (Green)</b></li>
    This robot is the output of the EKF-SLAM algorithm.
</ul>

The details of the project are summarized in the following sections.

<h5 style="font-family:montserrat">The Simulator</h5>  
For this project, Rviz was used as a visualization tool. I wrote a ROS node to provide a simulated robot environment used to test various components of the course, including the SLAM algorthim and landmark detection. The GIF above is an example of this simulation in action. In addition to simulating robot position, landmarks were added to the environment to test the detection algorithm based on LiDAR data. Collision detection between the simulated robot and these obstacles also had to be implemented from scratch.

<h5 style="font-family:montserrat">Landmark Detection</h5> 
Laser scan data was used to detect cylindrical landmarks for this project. This required a machine learning approach that combined both unsupervised (clustering) and supervised (circular regression) learning. Laser scanner points were clustered based on a distance threshold, and clusters with less than 3 points were discarded. With only clusters representing actual landmarks remaining, the next task was to filter out anything that was not circular. This was accomplished by implementing a <a href="https://nu-msr.github.io/navigation_site/lectures/circle_fit.html">circle-fitting algorithm</a>. This final classification step helped eliminate false positives generated by the clustering algorithm. 

<h5 style="font-family:montserrat">The SLAM Algorithm</h5> 
The primary task of this project --- implementing EKF-SLAM --- was accomplished through an algorithm that consisted of three steps: initialization, prediction, and update. Each timestep uses odometry and sensor measurements to estimate the state of both the robot and landmarks. 
<h6 style="font-family:montserrat">Prediction</h6>   
To begin, the estimate of the full state vector $$\xi_t$$ is updated:  

$$
\begin{equation}
\hat{\xi_t^-} = g(\hat{\xi}_{t-1}, u_t, \epsilon)
\end{equation}
$$

Next, comes uncertainty propagation using the linearized state transition model (where $$\bar{Q}$$ is the process noise for the robot motion model):  

$$
\begin{equation}
\hat{\Sigma_t^-} = g'(\hat{\xi}_{t-1}, u_t, \epsilon) \ \hat{\Sigma}_{t-1} \ g'(\hat{\xi}_{t-1}, u_t,\epsilon)^T + \bar{Q}
\end{equation}
$$

<h6 style="font-family:montserrat">Update</h6> 
For each sensor measurement, the following steps are taken:  

- Compute theoretical measurement given current state estimate:  

$$
\begin{equation}
\hat{z_t}^i = h_j(\hat{\xi_t^-})
\end{equation}
$$

- Compute Kalman gain:  

$$
\begin{equation}
K_i = \Sigma_t^- h_j' \ (\xi_t)^T (h_j' \ (\xi_t) \ \Sigma_t^- \ h_j'(\xi_t)^T + R)^{-1}
\end{equation}
$$

- Compute posterior state update:  

$$
\begin{equation}
\hat{\xi_t} = \hat{\xi_t^-} + K_i (z_t^i - \hat{z_t^i})
\end{equation}
$$

- Compute posterior covariance:  

$$
\begin{equation}
\Sigma_t = (I - K_i h_j'(\xi_t)) \Sigma_t^-
\end{equation}
$$

<h5 style="font-family:montserrat">Helper Libraries</h5> 
Throughout the course, I wrote helper C++ libraries to handle calculations related to differential drive kinematics, 2D rigid body transformations, and other tasks. These can all be found in the <a href="https://github.com/mpjohns9/EKF-SLAM/tree/main/turtlelib"><i>turtlelib</i></a> directory of my respository.











